{"ast":null,"code":"var _jsxFileName = \"/home/albadri/Documents/videoChatApp/client/src/routes/Room.js\",\n  _s = $RefreshSig$();\nimport { useRef, useEffect } from \"react\";\nimport { useParams } from \"react-router-dom\";\nimport io from \"socket.io-client\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Room = props => {\n  _s();\n  const userVideo = useRef();\n  const partnerVideo = useRef();\n  const peerRef = useRef();\n  const socketRef = useRef();\n  const otherUser = useRef();\n  const userStream = useRef();\n  const {\n    roomID\n  } = useParams();\n  useEffect(() => {\n    // Ask the user for permission to use the webcam and microphone\n    navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: true\n    }).then(stream => {\n      userVideo.current.srcObject = stream;\n      userStream.current = stream;\n      // We connect to the socket.io server\n      socketRef.current = io.connect(\"http://localhost:3001/\");\n      // We send the roomID to the server\n      socketRef.current.emit(\"join room\", roomID);\n\n      // we get the ID of the other user\n      socketRef.current.on(\"other user\", userID => {\n        // we call the other user (the one who created the room)\n        callUser(userID);\n        // we save the ID of the other user\n        otherUser.current = userID;\n      });\n      // the one who created the room gets the ID of the other user\n      socketRef.current.on(\"user joined\", userID => {\n        otherUser.current = userID;\n      });\n      // This event is called wehen we receive an offer and we will then emit an answer to the server\n      socketRef.current.on(\"offer\", handleRecieveCall);\n      // This event handle the answer we receive from the server\n      socketRef.current.on(\"answer\", handleAnswer);\n      //\n      socketRef.current.on(\"ice-candidate\", handleNewICECandidateMsg);\n    });\n  }, []);\n  function callUser(userID) {\n    // create a peer object\n    peerRef.current = createPeer(userID);\n    // we get the stream of the user who is calling and we add it to the peer object to then send it to the other user\n    userStream.current.getTracks().forEach(track => peerRef.current.addTrack(track, userStream.current));\n  }\n  // userID represents the ID of the user trying to call us\n  function createPeer(userID) {\n    /* Create a peer object, the iceServers contains an url for the stun and turn server\n    these server job is to help the peer object to find the best way to connect to the other peer by bypassing\n     the firewall, NAT an other netowrk problems depending on the router configuration*/\n    const peer = new RTCPeerConnection({\n      iceServers: [{\n        urls: \"stun:stun.stunprotocol.org\" // stun:stun.stunprotocol.org is a famous free public stun server\n      }, {\n        urls: \"turn:numb.viagenie.ca\",\n        // turn:numb.viagenie.ca is a free public turn server\n        credential: \"muazkh\",\n        // the password for the turn server\n        username: \"webrtc@live.com\" // the username for the turn server\n      }]\n    });\n    // onicecandidate event is called when the peer object find a candidate to connect to the other peer\n    peer.onicecandidate = e => {\n      if (e.candidate) {\n        const payload = {\n          target: otherUser.current,\n          candidate: e.candidate\n        };\n        socketRef.current.emit(\"ice-candidate\", payload);\n      }\n    };\n    // on track event is called when a connection is established and we can start to stream the video. HandleTrackEvent will display the video of the other user\n    peer.ontrack = handleTrackEvent;\n    /* This event is called when there's a change like a user change his camera or microphone.\n     In this case we will update the connection with the new informations without restart the connection \n     instead of restart the connection at zero We use onegotionneeded to avoid to\n      recreate a call with peer.onicecandidate and peer.ontrack. (The one who change the connection is responsible to initiate the negotiation) */\n    peer.onnegotiationneeded = () => handleNegotiationNeededEvent(userID);\n    return peer;\n  }\n  function handleNegotiationNeededEvent(userID) {\n    // Create an offer to the other user\n    peerRef.current.createOffer().then(offer => {\n      // Change the curent description of the peer object to the offer we just created\n      return peerRef.current.setLocalDescription(offer);\n    }).then(() => {\n      const payload = {\n        target: userID,\n        caller: socketRef.current.id,\n        sdp: peerRef.current.localDescription\n      };\n      // We send the offer to the server to send it to the other user\n      socketRef.current.emit(\"offer\", payload);\n    }).catch(e => console.log(e));\n  }\n  function handleRecieveCall(inComingPayload) {\n    // we are receiving an offer from the other user so our createPeer dosen't need an ID\n    peerRef.current = createPeer();\n    const desc = new RTCSessionDescription(inComingPayload.sdp);\n    // Set the description with the offer we received from the other user\n    peerRef.current.setRemoteDescription(desc).then(() => {\n      userStream.current // we get the stream of the user who is receiving the call\n      .getTracks() // we get the tracks of the stream\n      .forEach(track => peerRef.current.addTrack(track, userStream.current) // we add the tracks to the peer object\n      );\n    }).then(() => {\n      // we create an answer to the offer we received\n      return peerRef.current.createAnswer();\n    }).then(answer => {\n      // we set the description of the peer object to the answer we just created\n      return peerRef.current.setLocalDescription(answer);\n    }).then(() => {\n      const payload = {\n        target: inComingPayload.caller,\n        // who he is\n        caller: socketRef.current.id,\n        // who i am\n        sdp: peerRef.current.localDescription // the description of the peer object\n      };\n      // we send the payload to the server to send it to the other user\n      socketRef.current.emit(\"answer\", payload);\n    });\n  }\n  function handleAnswer(message) {\n    const desc = new RTCSessionDescription(message.sdp);\n    // we set the description of the other user peer object with the answer we received from him\n    peerRef.current.setRemoteDescription(desc).catch(e => console.log(e));\n  }\n\n  // This function will be called when we receive an ice candidate from the other user\n  function handleNewICECandidateMsg(inComingPayload) {\n    // get the ice candidate\n    const candidate = new RTCIceCandidate(inComingPayload);\n    // add the ice candidate to the peer object and try to estiblish a connection\n    peerRef.current.addIceCandidate(candidate).catch(e => console.log(e));\n  }\n  function handleTrackEvent(e) {\n    // we set the source of the video to the stream of the other user, partnerVideo is the video element\n    partnerVideo.current.srcObject = e.streams[0];\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"video\", {\n      autoPlay: true,\n      ref: userVideo\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"video\", {\n      autoPlay: true,\n      ref: partnerVideo\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 164,\n    columnNumber: 5\n  }, this);\n};\n_s(Room, \"Xu80Y4tN9nmS+Qu2MEuWBFdnlDI=\", false, function () {\n  return [useParams];\n});\n_c = Room;\nexport default Room;\nvar _c;\n$RefreshReg$(_c, \"Room\");","map":{"version":3,"names":["useRef","useEffect","useParams","io","Room","props","userVideo","partnerVideo","peerRef","socketRef","otherUser","userStream","roomID","navigator","mediaDevices","getUserMedia","audio","video","then","stream","current","srcObject","connect","emit","on","userID","callUser","handleRecieveCall","handleAnswer","handleNewICECandidateMsg","createPeer","getTracks","forEach","track","addTrack","peer","RTCPeerConnection","iceServers","urls","credential","username","onicecandidate","e","candidate","payload","target","ontrack","handleTrackEvent","onnegotiationneeded","handleNegotiationNeededEvent","createOffer","offer","setLocalDescription","caller","id","sdp","localDescription","catch","console","log","inComingPayload","desc","RTCSessionDescription","setRemoteDescription","createAnswer","answer","message","RTCIceCandidate","addIceCandidate","streams"],"sources":["/home/albadri/Documents/videoChatApp/client/src/routes/Room.js"],"sourcesContent":["import { useRef, useEffect } from \"react\";\nimport { useParams } from \"react-router-dom\";\nimport io from \"socket.io-client\";\nconst Room = (props) => {\n  const userVideo = useRef();\n  const partnerVideo = useRef();\n  const peerRef = useRef();\n  const socketRef = useRef();\n  const otherUser = useRef();\n  const userStream = useRef();\n  const { roomID } = useParams();\n\n  useEffect(() => {\n    // Ask the user for permission to use the webcam and microphone\n    navigator.mediaDevices\n      .getUserMedia({ audio: true, video: true })\n      .then((stream) => {\n        userVideo.current.srcObject = stream;\n        userStream.current = stream;\n        // We connect to the socket.io server\n        socketRef.current = io.connect(\"http://localhost:3001/\");\n        // We send the roomID to the server\n        socketRef.current.emit(\"join room\", roomID);\n\n        // we get the ID of the other user\n        socketRef.current.on(\"other user\", (userID) => {\n          // we call the other user (the one who created the room)\n          callUser(userID);\n          // we save the ID of the other user\n          otherUser.current = userID;\n        });\n        // the one who created the room gets the ID of the other user\n        socketRef.current.on(\"user joined\", (userID) => {\n          otherUser.current = userID;\n        });\n        // This event is called wehen we receive an offer and we will then emit an answer to the server\n        socketRef.current.on(\"offer\", handleRecieveCall);\n        // This event handle the answer we receive from the server\n        socketRef.current.on(\"answer\", handleAnswer);\n        //\n        socketRef.current.on(\"ice-candidate\", handleNewICECandidateMsg);\n      });\n  }, []);\n\n  function callUser(userID) {\n    // create a peer object\n    peerRef.current = createPeer(userID);\n    // we get the stream of the user who is calling and we add it to the peer object to then send it to the other user\n    userStream.current\n      .getTracks()\n      .forEach((track) => peerRef.current.addTrack(track, userStream.current));\n  }\n  // userID represents the ID of the user trying to call us\n  function createPeer(userID) {\n    /* Create a peer object, the iceServers contains an url for the stun and turn server\n    these server job is to help the peer object to find the best way to connect to the other peer by bypassing\n     the firewall, NAT an other netowrk problems depending on the router configuration*/\n    const peer = new RTCPeerConnection({\n      iceServers: [\n        {\n          urls: \"stun:stun.stunprotocol.org\", // stun:stun.stunprotocol.org is a famous free public stun server\n        },\n        {\n          urls: \"turn:numb.viagenie.ca\", // turn:numb.viagenie.ca is a free public turn server\n          credential: \"muazkh\", // the password for the turn server\n          username: \"webrtc@live.com\", // the username for the turn server\n        },\n      ],\n    });\n    // onicecandidate event is called when the peer object find a candidate to connect to the other peer\n    peer.onicecandidate = (e) => {\n      if (e.candidate) {\n        const payload = {\n          target: otherUser.current,\n          candidate: e.candidate,\n        };\n        socketRef.current.emit(\"ice-candidate\", payload);\n      }\n    };\n    // on track event is called when a connection is established and we can start to stream the video. HandleTrackEvent will display the video of the other user\n    peer.ontrack = handleTrackEvent;\n    /* This event is called when there's a change like a user change his camera or microphone.\n     In this case we will update the connection with the new informations without restart the connection \n     instead of restart the connection at zero We use onegotionneeded to avoid to\n      recreate a call with peer.onicecandidate and peer.ontrack. (The one who change the connection is responsible to initiate the negotiation) */\n    peer.onnegotiationneeded = () => handleNegotiationNeededEvent(userID);\n\n    return peer;\n  }\n\n  function handleNegotiationNeededEvent(userID) {\n    // Create an offer to the other user\n    peerRef.current\n      .createOffer()\n      .then((offer) => {\n        // Change the curent description of the peer object to the offer we just created\n        return peerRef.current.setLocalDescription(offer);\n      })\n      .then(() => {\n        const payload = {\n          target: userID,\n          caller: socketRef.current.id,\n          sdp: peerRef.current.localDescription,\n        };\n        // We send the offer to the server to send it to the other user\n        socketRef.current.emit(\"offer\", payload);\n      })\n      .catch((e) => console.log(e));\n  }\n\n  function handleRecieveCall(inComingPayload) {\n    // we are receiving an offer from the other user so our createPeer dosen't need an ID\n    peerRef.current = createPeer();\n    const desc = new RTCSessionDescription(inComingPayload.sdp);\n    // Set the description with the offer we received from the other user\n    peerRef.current\n      .setRemoteDescription(desc)\n      .then(() => {\n        userStream.current // we get the stream of the user who is receiving the call\n          .getTracks() // we get the tracks of the stream\n          .forEach(\n            (track) => peerRef.current.addTrack(track, userStream.current) // we add the tracks to the peer object\n          );\n      })\n      .then(() => {\n        // we create an answer to the offer we received\n        return peerRef.current.createAnswer();\n      })\n      .then((answer) => {\n        // we set the description of the peer object to the answer we just created\n        return peerRef.current.setLocalDescription(answer);\n      })\n      .then(() => {\n        const payload = {\n          target: inComingPayload.caller, // who he is\n          caller: socketRef.current.id, // who i am\n          sdp: peerRef.current.localDescription, // the description of the peer object\n        };\n        // we send the payload to the server to send it to the other user\n        socketRef.current.emit(\"answer\", payload);\n      });\n  }\n\n  function handleAnswer(message) {\n    const desc = new RTCSessionDescription(message.sdp);\n    // we set the description of the other user peer object with the answer we received from him\n    peerRef.current.setRemoteDescription(desc).catch((e) => console.log(e));\n  }\n\n  // This function will be called when we receive an ice candidate from the other user\n  function handleNewICECandidateMsg(inComingPayload) {\n    // get the ice candidate\n    const candidate = new RTCIceCandidate(inComingPayload);\n    // add the ice candidate to the peer object and try to estiblish a connection\n    peerRef.current.addIceCandidate(candidate).catch((e) => console.log(e));\n  }\n\n  function handleTrackEvent(e) {\n    // we set the source of the video to the stream of the other user, partnerVideo is the video element\n    partnerVideo.current.srcObject = e.streams[0];\n  }\n\n  return (\n    <div>\n      {/* This will display our cam */}\n      <video autoPlay ref={userVideo} />\n      {/* This will display the oponnent cam */}\n      <video autoPlay ref={partnerVideo} />\n    </div>\n  );\n};\n\nexport default Room;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}